from pyDatalog import pyDatalog
import random
import numpy as np
import sys
import time


class Block(object):
    def __init__(self,x,y,value,status):
        self.status= status
        self.x = x
        self.y = y
        self.value = value



class Agent():
    def __init__(self):
        self.x = 0
        self.y = 0
        self.value=0
        self.flaglist=[]
        self.securelist=[]
        self.watchlist=[]
        self.knowledgebase=[]


    def infinite_expand(self):
        i,j = (self.x,self.y)
        self.value = (grid[i][j]).value
        list1 = self.find_neibor()
        for element in list1:
            block = grid[element[0]][element[1]]
            if block.status=='unsearched':
                block.status = 'safe'
            if block.value == 0 and (block.x,block.y) not in self.securelist:
                self.securelist.append((block.x,block.y))
                (self.x,self.y) = (block.x,block.y)
                # block.status = 'used'
                self.infinite_expand()

            elif block.value!=0:
                if (block.x,block.y) not in self.watchlist:
                    self.watchlist.append((block.x,block.y))


    def birth(self):
        x = random.randint(0,8)
        y = random.randint(0,8)
        self.x=x
        self.y=y
        block = grid[x][y]
        if block.value==0:
            block.status = 'used'
            self.securelist.append((x,y))
            self.infinite_expand()
        elif block.value == -1:
            block.status = 'explode'
            self.birth()
        else:
            self.watchlist.append((x,y))
            self.status='safe'
            self.birth()


        
    def find_neibor(self):
        x,y = (self.x,self.y)
        neiborlist=[]
        for positions in [(x-1,y+1),(x-1,y),(x-1,y-1),(x,y+1),(x,y-1),(x+1,y+1),(x+1,y),(x+1,y-1)]:
            if (positions[0]<9) and (positions[0]>=0) and (positions[1]<9) and (positions[1]>=0):
                neiborlist.append(positions)
        return neiborlist

    def collect_information(self):
        list2 = self.find_neibor()
        mine = 0
        unsearchlist= []
        for element in list2:
            x,y=(element[0],element[1])
            block = grid[x][y]
            if block.status == 'flag':
                mine=mine+1
            elif block.status =='unsearched':
                unsearchlist.append((block.x,block.y))
        return self.value,mine,unsearchlist


    def violentflag(self,value,mine,unsearchlist):
        # list = self.find_neibor
        # value = self.value
        # mine = 0
        # unsearchlist=[]
        # for block in list:
        #     if block.status == 'flag':
        #         mine = mine + 1
        #     elif block.status == 'unsearched'
        #         unsearchlist.append(block)

        if len(unsearchlist) == value - mine:
            for element in unsearchlist:
                block = grid[element[0]][element[1]]
                block.status = 'flag'
                self.flaglist.append((block.x,block.y))
            self.securelist.append((self.x,self.y))
            self.status = 'used'
            if (self.x,self.y) in self.watchlist:
                self.watchlist.remove((self.x,self.y))







    def violentmark(self,value,mine,unsearchlist):
        # list = self.find_neibor
        # value = self.value
        # mine = 0
        # unsearchlist = []
        # for block in list:
        #     if block.status == 'flag':
        #         mine = mine + 1
        #     elif block.status == 'unsearched'
        #         unsearchlist.append(block)

        if value==mine:
            for element in unsearchlist:
                block = grid[element[0]][element[1]]
                if block.status == 'unsearched':
                    block.status = 'safe'
                if (block.x,block.y) not in self.watchlist:
                    self.watchlist.append((block.x,block.y))
                if (self.x,self.y) not in self.securelist:
                    self.securelist.append((self.x,self.y))
                if (self.x,self.y) in self.watchlist:
                    self.watchlist.remove((self.x,self.y))
                self.status ='used'
                if block.value == 0:
                    self.x = block.x
                    self.y = block.y
                    self.status = 'used'
                    self.securelist.append((self.x,self.y))
                    self.infinite_expand()

    def generate_knowledge(self,value,mine,watchlist):
        point = random.choice(watchlist)
        x,y = (point[0],point[1])
        self.x=x
        self.y=y
        value,mine,unsearchlist = self.collect_information()
        a = {}
        s = '0'
        for point in unsearchlist:
            x,y = (point.x,point.y)
            a[str(x)+'R'+str(y)]=0
            s=s+ '+'+str(a[str(x)+'R'+str(y)])
        s=s+'=='+str(value)
        self.knowledgebase.append(s)









def set_up_board(board):
    grid = [i for i in range(16)]
    for i in range(16):
        grid[i] = []
        for j in range(16):
            grid[i].append(0)

    for i in range(9):
        for j in range(9):
            x, y = (i, j)
            newblock = Block(x,y,board[i][j],'unsearched')
            grid[x][y] = newblock

    return grid

def show_status(grid):
    grid3 = np.ones((9,9))
    grid2 = grid3.astype(np.str)
    for i in range(9):
        for j in range(9):
            block = grid[i][j]
            if block.status == 'unsearched':
                grid2[i][j]='?'
            elif block.status == 'flag':
                grid2[i][j] = 'F'
            else:
                grid2[i][j] = block.value
    a=str(grid2)
    print(a)
    print()
    time.sleep(0.5)

board = [[-1,1,0,0,0,1,1,1,0],[2,2,0,0,0,1,-1,2,1],[-1,3,1,1,0,1,2,-1,1],
         [-1,3,-1,1,0,0,1,1,1],[2,3,1,1,0,0,0,0,0],[-1,2,1,1,0,0,0,0,0],
         [1,2,-1,2,1,1,0,0,0],[0,1,1,2,-1,2,1,0,0],[0,0,0,1,2,-1,1,0,0]]


if __name__ == '__main__' :
    grid = set_up_board(board)
    Ai = Agent()
    Ai.birth()
    show_status(grid)

    n = (Ai.watchlist).copy()
    k=[]
    while n!=k:
        n = (Ai.watchlist).copy()

        for point in Ai.watchlist:
            Ai.x = point[0]
            Ai.y = point[1]
            Ai.value = grid[Ai.x][Ai.y].value
            value,mine,unsearchlist = Ai.collect_information()
            Ai.violentflag(value, mine, unsearchlist)
            Ai.violentmark(value,mine,unsearchlist)

        show_status(grid)


        k=(Ai.watchlist).copy()

    #     '''
    #
